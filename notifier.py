#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
üèÜ ÌÄ∏Ìä∏ÌîÑÎ°úÏ†ùÌä∏ ÌÜµÌï© ÏïåÎ¶º ÏãúÏä§ÌÖú (notifier.py)
=================================================
ÌÖîÎ†àÍ∑∏Îû® + Ïù¥Î©îÏùº + Ïä¨Îûô + ÎîîÏä§ÏΩîÎìú + SMS ÌÜµÌï© ÏïåÎ¶º

‚ú® ÌïµÏã¨ Í∏∞Îä•:
- Îã§Ï§ë Ï±ÑÎÑê ÏïåÎ¶º (ÌÖîÎ†àÍ∑∏Îû®, Ïù¥Î©îÏùº, Ïä¨Îûô, ÎîîÏä§ÏΩîÎìú, SMS)
- ÏïåÎ¶º Î†àÎ≤®Î≥Ñ ÏûêÎèô ÎùºÏö∞ÌåÖ (INFO, WARNING, CRITICAL)
- Ï§ëÎ≥µ ÏïåÎ¶º Î∞©ÏßÄ ÏãúÏä§ÌÖú
- Ïã§Ìå® Ïãú ÎåÄÏïà Ï±ÑÎÑê ÏûêÎèô Ï†ÑÌôò
- ÏïåÎ¶º ÌÜµÍ≥Ñ Î∞è ÏÑ±Í≥µÎ•† Ï∂îÏ†Å
- ÌÖúÌîåÎ¶ø Í∏∞Î∞ò Î©îÏãúÏßÄ Ìè¨Îß∑ÌåÖ
- Ï≤®Î∂ÄÌååÏùº ÏßÄÏõê (Ïù¥ÎØ∏ÏßÄ, Î¨∏ÏÑú)

Author: ÌÄ∏Ìä∏ÎßàÏä§ÌÑ∞ÌåÄ
Version: 1.0.0
"""

import asyncio
import aiohttp
import smtplib
import logging
import os
import json
import time
import hashlib
from datetime import datetime, timedelta
from email.mime.text import MimeText
from email.mime.multipart import MimeMultipart
from email.mime.image import MimeImage
from email.mime.base import MimeBase
from email import encoders
from pathlib import Path
from typing import Dict, List, Optional, Union, Any
from dataclasses import dataclass, field
from enum import Enum
import sqlite3
import requests
from dotenv import load_dotenv

# ÌôòÍ≤ΩÎ≥ÄÏàò Î°úÎìú
load_dotenv()

# Î°úÍπÖ ÏÑ§Ï†ï
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s | %(name)s | %(levelname)s | %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('notifier.log', encoding='utf-8')
    ]
)
logger = logging.getLogger(__name__)

# ============================================================================
# üì± ÏïåÎ¶º Î†àÎ≤® Î∞è Îç∞Ïù¥ÌÑ∞ ÌÅ¥ÎûòÏä§
# ============================================================================

class NotificationLevel(Enum):
    """ÏïåÎ¶º Î†àÎ≤®"""
    DEBUG = "debug"
    INFO = "info"
    WARNING = "warning"
    CRITICAL = "critical"
    EMERGENCY = "emergency"

class NotificationChannel(Enum):
    """ÏïåÎ¶º Ï±ÑÎÑê"""
    TELEGRAM = "telegram"
    EMAIL = "email"
    SLACK = "slack"
    DISCORD = "discord"
    SMS = "sms"
    WEBHOOK = "webhook"

@dataclass
class NotificationConfig:
    """ÏïåÎ¶º ÏÑ§Ï†ï"""
    # ÌÖîÎ†àÍ∑∏Îû®
    telegram_enabled: bool = False
    telegram_bot_token: str = ""
    telegram_chat_id: str = ""
    
    # Ïù¥Î©îÏùº
    email_enabled: bool = False
    email_smtp_server: str = "smtp.gmail.com"
    email_smtp_port: int = 587
    email_username: str = ""
    email_password: str = ""
    email_to: List[str] = field(default_factory=list)
    
    # Ïä¨Îûô
    slack_enabled: bool = False
    slack_webhook_url: str = ""
    slack_channel: str = ""
    slack_bot_token: str = ""
    
    # ÎîîÏä§ÏΩîÎìú
    discord_enabled: bool = False
    discord_webhook_url: str = ""
    
    # SMS (Twilio)
    sms_enabled: bool = False
    sms_account_sid: str = ""
    sms_auth_token: str = ""
    sms_from_number: str = ""
    sms_to_numbers: List[str] = field(default_factory=list)
    
    # ÏùºÎ∞ò ÏõπÌõÖ
    webhook_enabled: bool = False
    webhook_urls: List[str] = field(default_factory=list)
    
    # Î†àÎ≤®Î≥Ñ Ï±ÑÎÑê ÏÑ§Ï†ï
    level_channels: Dict[str, List[str]] = field(default_factory=dict)
    
    # Ï§ëÎ≥µ Î∞©ÏßÄ ÏÑ§Ï†ï
    duplicate_prevention: bool = True
    duplicate_window_minutes: int = 5
    
    # Ïû¨ÏãúÎèÑ ÏÑ§Ï†ï
    max_retries: int = 3
    retry_delay_seconds: int = 5

@dataclass
class NotificationMessage:
    """ÏïåÎ¶º Î©îÏãúÏßÄ"""
    title: str
    message: str
    level: NotificationLevel = NotificationLevel.INFO
    channels: Optional[List[NotificationChannel]] = None
    attachments: Optional[List[str]] = None
    metadata: Optional[Dict[str, Any]] = None
    timestamp: datetime = field(default_factory=datetime.now)
    message_id: Optional[str] = None

@dataclass
class NotificationResult:
    """ÏïåÎ¶º Í≤∞Í≥º"""
    channel: NotificationChannel
    success: bool
    message: str
    timestamp: datetime
    retry_count: int = 0
    response_data: Optional[Dict] = None

# ============================================================================
# üîß ÏïåÎ¶º ÏÑ§Ï†ï Í¥ÄÎ¶¨Ïûê
# ============================================================================

class NotificationConfigManager:
    """ÏïåÎ¶º ÏÑ§Ï†ï Í¥ÄÎ¶¨"""
    
    def __init__(self, config_file: str = "notification_config.json"):
        self.config_file = config_file
        self.config = self._load_config()
    
    def _load_config(self) -> NotificationConfig:
        """ÏÑ§Ï†ï ÌååÏùº Î°úÎìú"""
        try:
            # ÌååÏùºÏóêÏÑú Î°úÎìú
            if Path(self.config_file).exists():
                with open(self.config_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    return NotificationConfig(**data)
            
            # ÌôòÍ≤ΩÎ≥ÄÏàòÏóêÏÑú Î°úÎìú
            return self._load_from_env()
            
        except Exception as e:
            logger.error(f"ÏÑ§Ï†ï Î°úÎìú Ïã§Ìå®: {e}")
            return NotificationConfig()
    
    def _load_from_env(self) -> NotificationConfig:
        """ÌôòÍ≤ΩÎ≥ÄÏàòÏóêÏÑú ÏÑ§Ï†ï Î°úÎìú"""
        config = NotificationConfig(
            # ÌÖîÎ†àÍ∑∏Îû®
            telegram_enabled=os.getenv('TELEGRAM_ENABLED', 'false').lower() == 'true',
            telegram_bot_token=os.getenv('TELEGRAM_BOT_TOKEN', ''),
            telegram_chat_id=os.getenv('TELEGRAM_CHAT_ID', ''),
            
            # Ïù¥Î©îÏùº
            email_enabled=os.getenv('EMAIL_ENABLED', 'false').lower() == 'true',
            email_smtp_server=os.getenv('EMAIL_SMTP_SERVER', 'smtp.gmail.com'),
            email_smtp_port=int(os.getenv('EMAIL_SMTP_PORT', '587')),
            email_username=os.getenv('EMAIL_USERNAME', ''),
            email_password=os.getenv('EMAIL_PASSWORD', ''),
            email_to=os.getenv('EMAIL_TO', '').split(',') if os.getenv('EMAIL_TO') else [],
            
            # Ïä¨Îûô
            slack_enabled=os.getenv('SLACK_ENABLED', 'false').lower() == 'true',
            slack_webhook_url=os.getenv('SLACK_WEBHOOK_URL', ''),
            slack_channel=os.getenv('SLACK_CHANNEL', '#general'),
            slack_bot_token=os.getenv('SLACK_BOT_TOKEN', ''),
            
            # ÎîîÏä§ÏΩîÎìú
            discord_enabled=os.getenv('DISCORD_ENABLED', 'false').lower() == 'true',
            discord_webhook_url=os.getenv('DISCORD_WEBHOOK_URL', ''),
            
            # SMS
            sms_enabled=os.getenv('SMS_ENABLED', 'false').lower() == 'true',
            sms_account_sid=os.getenv('SMS_ACCOUNT_SID', ''),
            sms_auth_token=os.getenv('SMS_AUTH_TOKEN', ''),
            sms_from_number=os.getenv('SMS_FROM_NUMBER', ''),
            sms_to_numbers=os.getenv('SMS_TO_NUMBERS', '').split(',') if os.getenv('SMS_TO_NUMBERS') else [],
            
            # ÏõπÌõÖ
            webhook_enabled=os.getenv('WEBHOOK_ENABLED', 'false').lower() == 'true',
            webhook_urls=os.getenv('WEBHOOK_URLS', '').split(',') if os.getenv('WEBHOOK_URLS') else [],
            
            # Î†àÎ≤®Î≥Ñ Ï±ÑÎÑê ÏÑ§Ï†ï
            level_channels={
                'debug': ['telegram'],
                'info': ['telegram', 'slack'],
                'warning': ['telegram', 'email', 'slack'],
                'critical': ['telegram', 'email', 'slack', 'discord'],
                'emergency': ['telegram', 'email', 'slack', 'discord', 'sms']
            }
        )
        
        # ÏÑ§Ï†ï ÌååÏùº Ï†ÄÏû•
        self.save_config(config)
        return config
    
    def save_config(self, config: NotificationConfig):
        """ÏÑ§Ï†ï ÌååÏùº Ï†ÄÏû•"""
        try:
            with open(self.config_file, 'w', encoding='utf-8') as f:
                json.dump(config.__dict__, f, indent=2, ensure_ascii=False, default=str)
            logger.info(f"‚úÖ ÏÑ§Ï†ï Ï†ÄÏû•: {self.config_file}")
        except Exception as e:
            logger.error(f"ÏÑ§Ï†ï Ï†ÄÏû• Ïã§Ìå®: {e}")
    
    def update_config(self, **kwargs):
        """ÏÑ§Ï†ï ÏóÖÎç∞Ïù¥Ìä∏"""
        for key, value in kwargs.items():
            if hasattr(self.config, key):
                setattr(self.config, key, value)
        self.save_config(self.config)

# ============================================================================
# üìä ÏïåÎ¶º ÌÜµÍ≥Ñ Í¥ÄÎ¶¨Ïûê
# ============================================================================

class NotificationStatsManager:
    """ÏïåÎ¶º ÌÜµÍ≥Ñ Í¥ÄÎ¶¨"""
    
    def __init__(self, db_path: str = "notification_stats.db"):
        self.db_path = db_path
        self._init_database()
    
    def _init_database(self):
        """Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï¥àÍ∏∞Ìôî"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            # ÏïåÎ¶º Í∏∞Î°ù ÌÖåÏù¥Î∏î
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS notification_logs (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    message_id TEXT,
                    title TEXT,
                    level TEXT,
                    channel TEXT,
                    success BOOLEAN,
                    error_message TEXT,
                    retry_count INTEGER DEFAULT 0,
                    timestamp DATETIME,
                    response_time_ms INTEGER
                )
            ''')
            
            # Ï§ëÎ≥µ Î∞©ÏßÄ ÌÖåÏù¥Î∏î
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS duplicate_prevention (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    message_hash TEXT UNIQUE,
                    first_sent DATETIME,
                    count INTEGER DEFAULT 1
                )
            ''')
            
            # Ï±ÑÎÑêÎ≥Ñ ÌÜµÍ≥Ñ ÌÖåÏù¥Î∏î
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS channel_stats (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    channel TEXT,
                    date DATE,
                    total_sent INTEGER DEFAULT 0,
                    successful_sent INTEGER DEFAULT 0,
                    failed_sent INTEGER DEFAULT 0,
                    avg_response_time_ms REAL DEFAULT 0,
                    UNIQUE(channel, date)
                )
            ''')
            
            conn.commit()
            conn.close()
            logger.info("‚úÖ ÏïåÎ¶º ÌÜµÍ≥Ñ DB Ï¥àÍ∏∞Ìôî ÏôÑÎ£å")
            
        except Exception as e:
            logger.error(f"ÌÜµÍ≥Ñ DB Ï¥àÍ∏∞Ìôî Ïã§Ìå®: {e}")
    
    def log_notification(self, message: NotificationMessage, result: NotificationResult, response_time_ms: int):
        """ÏïåÎ¶º Î°úÍ∑∏ Í∏∞Î°ù"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            cursor.execute('''
                INSERT INTO notification_logs 
                (message_id, title, level, channel, success, error_message, retry_count, timestamp, response_time_ms)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                message.message_id, message.title, message.level.value,
                result.channel.value, result.success, result.message,
                result.retry_count, result.timestamp.isoformat(), response_time_ms
            ))
            
            # ÏùºÏùº ÌÜµÍ≥Ñ ÏóÖÎç∞Ïù¥Ìä∏
            today = datetime.now().date()
            cursor.execute('''
                INSERT OR IGNORE INTO channel_stats (channel, date) VALUES (?, ?)
            ''', (result.channel.value, today))
            
            cursor.execute('''
                UPDATE channel_stats SET 
                    total_sent = total_sent + 1,
                    successful_sent = successful_sent + ?,
                    failed_sent = failed_sent + ?,
                    avg_response_time_ms = (avg_response_time_ms * (total_sent - 1) + ?) / total_sent
                WHERE channel = ? AND date = ?
            ''', (
                1 if result.success else 0,
                0 if result.success else 1,
                response_time_ms,
                result.channel.value, today
            ))
            
            conn.commit()
            conn.close()
            
        except Exception as e:
            logger.error(f"ÏïåÎ¶º Î°úÍ∑∏ Í∏∞Î°ù Ïã§Ìå®: {e}")
    
    def check_duplicate(self, message: NotificationMessage, window_minutes: int = 5) -> bool:
        """Ï§ëÎ≥µ Î©îÏãúÏßÄ Ï≤¥ÌÅ¨"""
        try:
            # Î©îÏãúÏßÄ Ìï¥Ïãú ÏÉùÏÑ±
            message_content = f"{message.title}:{message.message}:{message.level.value}"
            message_hash = hashlib.md5(message_content.encode()).hexdigest()
            
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            # ÏµúÍ∑º Ï§ëÎ≥µ Ï≤¥ÌÅ¨
            cutoff_time = datetime.now() - timedelta(minutes=window_minutes)
            cursor.execute('''
                SELECT count, first_sent FROM duplicate_prevention 
                WHERE message_hash = ? AND first_sent > ?
            ''', (message_hash, cutoff_time.isoformat()))
            
            result = cursor.fetchone()
            
            if result:
                # Ï§ëÎ≥µ Î∞úÍ≤¨ - Ïπ¥Ïö¥Ìä∏ Ï¶ùÍ∞Ä
                cursor.execute('''
                    UPDATE duplicate_prevention SET count = count + 1 
                    WHERE message_hash = ?
                ''', (message_hash,))
                conn.commit()
                conn.close()
                return True
            else:
                # ÏÉà Î©îÏãúÏßÄ - Í∏∞Î°ù
                cursor.execute('''
                    INSERT OR REPLACE INTO duplicate_prevention (message_hash, first_sent, count)
                    VALUES (?, ?, 1)
                ''', (message_hash, datetime.now().isoformat()))
                conn.commit()
                conn.close()
                return False
                
        except Exception as e:
            logger.error(f"Ï§ëÎ≥µ Ï≤¥ÌÅ¨ Ïã§Ìå®: {e}")
            return False
    
    def get_stats(self, days: int = 7) -> Dict[str, Any]:
        """ÌÜµÍ≥Ñ Ï°∞Ìöå"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            cutoff_date = datetime.now().date() - timedelta(days=days)
            
            # Ï±ÑÎÑêÎ≥Ñ ÌÜµÍ≥Ñ
            cursor.execute('''
                SELECT channel, 
                       SUM(total_sent) as total,
                       SUM(successful_sent) as success,
                       SUM(failed_sent) as failed,
                       AVG(avg_response_time_ms) as avg_response
                FROM channel_stats 
                WHERE date > ?
                GROUP BY channel
            ''', (cutoff_date,))
            
            channel_stats = {}
            for row in cursor.fetchall():
                channel_stats[row[0]] = {
                    'total_sent': row[1],
                    'successful_sent': row[2],
                    'failed_sent': row[3],
                    'success_rate': (row[2] / row[1] * 100) if row[1] > 0 else 0,
                    'avg_response_time_ms': row[4] or 0
                }
            
            # Î†àÎ≤®Î≥Ñ ÌÜµÍ≥Ñ
            cursor.execute('''
                SELECT level, COUNT(*) as count
                FROM notification_logs 
                WHERE date(timestamp) > ?
                GROUP BY level
            ''', (cutoff_date,))
            
            level_stats = {row[0]: row[1] for row in cursor.fetchall()}
            
            conn.close()
            
            return {
                'period_days': days,
                'channel_stats': channel_stats,
                'level_stats': level_stats,
                'total_notifications': sum(level_stats.values()),
                'generated_at': datetime.now().isoformat()
            }
            
        except Exception as e:
            logger.error(f"ÌÜµÍ≥Ñ Ï°∞Ìöå Ïã§Ìå®: {e}")
            return {}

# ============================================================================
# üì§ Í∞úÎ≥Ñ Ï±ÑÎÑê Ìï∏Îì§Îü¨
# ============================================================================

class TelegramHandler:
    """ÌÖîÎ†àÍ∑∏Îû® ÏïåÎ¶º Ìï∏Îì§Îü¨"""
    
    def __init__(self, bot_token: str, chat_id: str):
        self.bot_token = bot_token
        self.chat_id = chat_id
        self.base_url = f"https://api.telegram.org/bot{bot_token}"
    
    async def send_message(self, message: NotificationMessage) -> NotificationResult:
        """ÌÖîÎ†àÍ∑∏Îû® Î©îÏãúÏßÄ Ï†ÑÏÜ°"""
        start_time = time.time()
        
        try:
            # Î©îÏãúÏßÄ Ìè¨Îß∑ÌåÖ
            level_emoji = {
                NotificationLevel.DEBUG: 'üîç',
                NotificationLevel.INFO: 'üí°',
                NotificationLevel.WARNING: '‚ö†Ô∏è',
                NotificationLevel.CRITICAL: 'üö®',
                NotificationLevel.EMERGENCY: 'üÜò'
            }
            
            emoji = level_emoji.get(message.level, 'üì¢')
            formatted_message = f"{emoji} <b>{message.title}</b>\n\n{message.message}\n\n‚è∞ {message.timestamp.strftime('%Y-%m-%d %H:%M:%S')}"
            
            data = {
                'chat_id': self.chat_id,
                'text': formatted_message,
                'parse_mode': 'HTML',
                'disable_web_page_preview': True
            }
            
            async with aiohttp.ClientSession() as session:
                async with session.post(f"{self.base_url}/sendMessage", json=data, timeout=30) as response:
                    response_data = await response.json()
                    
                    if response.status == 200 and response_data.get('ok'):
                        return NotificationResult(
                            channel=NotificationChannel.TELEGRAM,
                            success=True,
                            message="Ï†ÑÏÜ° ÏÑ±Í≥µ",
                            timestamp=datetime.now(),
                            response_data=response_data
                        )
                    else:
                        return NotificationResult(
                            channel=NotificationChannel.TELEGRAM,
                            success=False,
                            message=f"API Ïò§Î•ò: {response_data.get('description', 'Unknown error')}",
                            timestamp=datetime.now(),
                            response_data=response_data
                        )
            
        except Exception as e:
            return NotificationResult(
                channel=NotificationChannel.TELEGRAM,
                success=False,
                message=f"Ï†ÑÏÜ° Ïã§Ìå®: {str(e)}",
                timestamp=datetime.now()
            )

class EmailHandler:
    """Ïù¥Î©îÏùº ÏïåÎ¶º Ìï∏Îì§Îü¨"""
    
    def __init__(self, smtp_server: str, smtp_port: int, username: str, password: str, to_addresses: List[str]):
        self.smtp_server = smtp_server
        self.smtp_port = smtp_port
        self.username = username
        self.password = password
        self.to_addresses = to_addresses
    
    async def send_message(self, message: NotificationMessage) -> NotificationResult:
        """Ïù¥Î©îÏùº Î©îÏãúÏßÄ Ï†ÑÏÜ°"""
        try:
            # Î©îÏãúÏßÄ Íµ¨ÏÑ±
            msg = MimeMultipart()
            msg['From'] = self.username
            msg['To'] = ', '.join(self.to_addresses)
            msg['Subject'] = f"[{message.level.value.upper()}] {message.title}"
            
            # Î≥∏Î¨∏ ÏûëÏÑ±
            body = f"""
{message.title}

{message.message}

---
ÏïåÎ¶º Î†àÎ≤®: {message.level.value.upper()}
Î∞úÏÉù ÏãúÍ∞Ñ: {message.timestamp.strftime('%Y-%m-%d %H:%M:%S')}
ÏãúÏä§ÌÖú: ÌÄ∏Ìä∏ÌîÑÎ°úÏ†ùÌä∏ ÏïåÎ¶º ÏãúÏä§ÌÖú
"""
            
            msg.attach(MimeText(body, 'plain', 'utf-8'))
            
            # Ï≤®Î∂ÄÌååÏùº Ï≤òÎ¶¨
            if message.attachments:
                for attachment_path in message.attachments:
                    await self._add_attachment(msg, attachment_path)
            
            # ÎπÑÎèôÍ∏∞ Ï†ÑÏÜ°
            await asyncio.get_event_loop().run_in_executor(None, self._send_email_sync, msg)
            
            return NotificationResult(
                channel=NotificationChannel.EMAIL,
                success=True,
                message="Ïù¥Î©îÏùº Ï†ÑÏÜ° ÏÑ±Í≥µ",
                timestamp=datetime.now()
            )
            
        except Exception as e:
            return NotificationResult(
                channel=NotificationChannel.EMAIL,
                success=False,
                message=f"Ïù¥Î©îÏùº Ï†ÑÏÜ° Ïã§Ìå®: {str(e)}",
                timestamp=datetime.now()
            )
    
    def _send_email_sync(self, msg):
        """ÎèôÍ∏∞ Ïù¥Î©îÏùº Ï†ÑÏÜ°"""
        server = smtplib.SMTP(self.smtp_server, self.smtp_port)
        server.starttls()
        server.login(self.username, self.password)
        server.send_message(msg)
        server.quit()
    
    async def _add_attachment(self, msg, file_path: str):
        """Ï≤®Î∂ÄÌååÏùº Ï∂îÍ∞Ä"""
        try:
            file_path = Path(file_path)
            if not file_path.exists():
                return
            
            with open(file_path, 'rb') as f:
                if file_path.suffix.lower() in ['.jpg', '.jpeg', '.png', '.gif']:
                    # Ïù¥ÎØ∏ÏßÄ Ï≤®Î∂Ä
                    img_data = f.read()
                    image = MimeImage(img_data)
                    image.add_header('Content-Disposition', f'attachment; filename={file_path.name}')
                    msg.attach(image)
                else:
                    # ÏùºÎ∞ò ÌååÏùº Ï≤®Î∂Ä
                    part = MimeBase('application', 'octet-stream')
                    part.set_payload(f.read())
                    encoders.encode_base64(part)
                    part.add_header('Content-Disposition', f'attachment; filename={file_path.name}')
                    msg.attach(part)
                    
        except Exception as e:
            logger.error(f"Ï≤®Î∂ÄÌååÏùº Ï∂îÍ∞Ä Ïã§Ìå® {file_path}: {e}")

class SlackHandler:
    """Ïä¨Îûô ÏïåÎ¶º Ìï∏Îì§Îü¨"""
    
    def __init__(self, webhook_url: str, channel: str = "#general"):
        self.webhook_url = webhook_url
        self.channel = channel
    
    async def send_message(self, message: NotificationMessage) -> NotificationResult:
        """Ïä¨Îûô Î©îÏãúÏßÄ Ï†ÑÏÜ°"""
        try:
            # Î†àÎ≤®Î≥Ñ ÏÉâÏÉÅ
            level_colors = {
                NotificationLevel.DEBUG: "#36a64f",     # ÎÖπÏÉâ
                NotificationLevel.INFO: "#36a64f",      # ÎÖπÏÉâ
                NotificationLevel.WARNING: "#ff9500",   # Ï£ºÌô©ÏÉâ
                NotificationLevel.CRITICAL: "#ff0000",  # Îπ®Í∞ÑÏÉâ
                NotificationLevel.EMERGENCY: "#8B0000"  # ÏßÑÌïú Îπ®Í∞ÑÏÉâ
            }
            
            color = level_colors.get(message.level, "#36a64f")
            
            payload = {
                "channel": self.channel,
                "username": "QuintProject Bot",
                "icon_emoji": ":chart_with_upwards_trend:",
                "attachments": [
                    {
                        "color": color,
                        "title": f"[{message.level.value.upper()}] {message.title}",
                        "text": message.message,
                        "footer": "ÌÄ∏Ìä∏ÌîÑÎ°úÏ†ùÌä∏ ÏïåÎ¶º ÏãúÏä§ÌÖú",
                        "ts": int(message.timestamp.timestamp())
                    }
                ]
            }
            
            async with aiohttp.ClientSession() as session:
                async with session.post(self.webhook_url, json=payload, timeout=30) as response:
                    if response.status == 200:
                        return NotificationResult(
                            channel=NotificationChannel.SLACK,
                            success=True,
                            message="Ïä¨Îûô Ï†ÑÏÜ° ÏÑ±Í≥µ",
                            timestamp=datetime.now()
                        )
                    else:
                        error_text = await response.text()
                        return NotificationResult(
                            channel=NotificationChannel.SLACK,
                            success=False,
                            message=f"Ïä¨Îûô Ï†ÑÏÜ° Ïã§Ìå®: {error_text}",
                            timestamp=datetime.now()
                        )
            
        except Exception as e:
            return NotificationResult(
                channel=NotificationChannel.SLACK,
                success=False,
                message=f"Ïä¨Îûô Ï†ÑÏÜ° Ïò§Î•ò: {str(e)}",
                timestamp=datetime.now()
            )

class DiscordHandler:
    """ÎîîÏä§ÏΩîÎìú ÏïåÎ¶º Ìï∏Îì§Îü¨"""
    
    def __init__(self, webhook_url: str):
        self.webhook_url = webhook_url
    
    async def send_message(self, message: NotificationMessage) -> NotificationResult:
        """ÎîîÏä§ÏΩîÎìú Î©îÏãúÏßÄ Ï†ÑÏÜ°"""
        try:
            # Î†àÎ≤®Î≥Ñ ÏÉâÏÉÅ (10ÏßÑÏàò)
            level_colors = {
                NotificationLevel.DEBUG: 3066993,      # ÎÖπÏÉâ
                NotificationLevel.INFO: 3066993,       # ÎÖπÏÉâ
                NotificationLevel.WARNING: 16753920,   # Ï£ºÌô©ÏÉâ
                NotificationLevel.CRITICAL: 16711680,  # Îπ®Í∞ÑÏÉâ
                NotificationLevel.EMERGENCY: 9109504   # ÏßÑÌïú Îπ®Í∞ÑÏÉâ
            }
            
            color = level_colors.get(message.level, 3066993)
            
            payload = {
                "username": "QuintProject Bot",
                "avatar_url": "https://i.imgur.com/4M34hi2.png",
                "embeds": [
                    {
                        "title": f"[{message.level.value.upper()}] {message.title}",
                        "description": message.message,
                        "color": color,
                        "footer": {
                            "text": "ÌÄ∏Ìä∏ÌîÑÎ°úÏ†ùÌä∏ ÏïåÎ¶º ÏãúÏä§ÌÖú"
                        },
                        "timestamp": message.timestamp.isoformat()
                    }
                ]
            }
            
            async with aiohttp.ClientSession() as session:
                async with session.post(self.webhook_url, json=payload, timeout=30) as response:
                    if response.status == 204:  # DiscordÎäî 204 No Content Î∞òÌôò
                        return NotificationResult(
                            channel=NotificationChannel.DISCORD,
                            success=True,
                            message="ÎîîÏä§ÏΩîÎìú Ï†ÑÏÜ° ÏÑ±Í≥µ",
                            timestamp=datetime.now()
                        )
                    else:
                        error_text = await response.text()
                        return NotificationResult(
                            channel=NotificationChannel.DISCORD,
                            success=False,
                            message=f"ÎîîÏä§ÏΩîÎìú Ï†ÑÏÜ° Ïã§Ìå®: {error_text}",
                            timestamp=datetime.now()
                        )
            
        except Exception as e:
            return NotificationResult(
                channel=NotificationChannel.DISCORD,
                success=False,
                message=f"ÎîîÏä§ÏΩîÎìú Ï†ÑÏÜ° Ïò§Î•ò: {str(e)}",
                timestamp=datetime.now()
            )

class SMSHandler:
    """SMS ÏïåÎ¶º Ìï∏Îì§Îü¨ (Twilio)"""
    
    def __init__(self, account_sid: str, auth_token: str, from_number: str, to_numbers: List[str]):
        self.account_sid = account_sid
        self.auth_token = auth_token
        self.from_number = from_number
        self.to_numbers = to_numbers
    
    async def send_message(self, message: NotificationMessage) -> NotificationResult:
        """SMS Î©îÏãúÏßÄ Ï†ÑÏÜ°"""
        try:
            # SMSÎäî ÏßßÍ≤å ÏöîÏïΩ
            sms_text = f"[{message.level.value.upper()}] {message.title}\n{message.message[:100]}{'...' if len(message.message) > 100 else ''}"
            
            success_count = 0
            errors = []
            
            for to_number in self.to_numbers:
                try:
                    await self._send_single_sms(to_number, sms_text)
                    success_count += 1
                except Exception as e:
                    errors.append(f"{to_number}: {str(e)}")
            
            if success_count > 0:
                return NotificationResult(
                    channel=NotificationChannel.SMS,
                    success=True,
                    message=f"SMS Ï†ÑÏÜ° ÏÑ±Í≥µ: {success_count}/{len(self.to_numbers)}",
                    timestamp=datetime.now()
                )
            else:
                return NotificationResult(
                    channel=NotificationChannel.SMS,
                    success=False,
                    message=f"SMS Ï†ÑÏÜ° Ïã§Ìå®: {'; '.join(errors)}",
                    timestamp=datetime.now()
                )
            
        except Exception as e:
            return NotificationResult(
                channel=NotificationChannel.SMS,
                success=False,
                message=f"SMS Ï†ÑÏÜ° Ïò§Î•ò: {str(e)}",
                timestamp=datetime.now()
            )
    
    async def _send_single_sms(self, to_number: str, message_text: str):
        """Í∞úÎ≥Ñ SMS Ï†ÑÏÜ°"""
        try:
            from twilio.rest import Client
            
            client = Client(self.account_sid, self.auth_token)
            
            # ÎπÑÎèôÍ∏∞Î°ú Twilio API Ìò∏Ï∂ú
            await asyncio.get_event_loop().run_in_executor(
                None,
                lambda: client.messages.create(
                    body=message_text,
                    from_=self.from_number,
                    to=to_number
                )
            )
            
        except Exception as e:
            raise Exception(f"Twilio SMS Ï†ÑÏÜ° Ïã§Ìå®: {str(e)}")

class WebhookHandler:
    """ÏùºÎ∞ò ÏõπÌõÖ ÏïåÎ¶º Ìï∏Îì§Îü¨"""
    
    def __init__(self, webhook_urls: List[str]):
        self.webhook_urls = webhook_urls
    
    async def send_message(self, message: NotificationMessage) -> NotificationResult:
        """ÏõπÌõÖ Î©îÏãúÏßÄ Ï†ÑÏÜ°"""
        try:
            payload = {
                "title": message.title,
                "message": message.message,
                "level": message.level.value,
                "timestamp": message.timestamp.isoformat(),
                "metadata": message.metadata or {}
            }
            
            success_count = 0
            errors = []
            
            for webhook_url in self.webhook_urls:
                try:
                    async with aiohttp.ClientSession() as session:
                        async with session.post(webhook_url, json=payload, timeout=30) as response:
                            if response.status == 200:
                                success_count += 1
                            else:
                                errors.append(f"{webhook_url}: HTTP {response.status}")
                except Exception as e:
                    errors.append(f"{webhook_url}: {str(e)}")
            
            if success_count > 0:
                return NotificationResult(
                    channel=NotificationChannel.WEBHOOK,
                    success=True,
                    message=f"ÏõπÌõÖ Ï†ÑÏÜ° ÏÑ±Í≥µ: {success_count}/{len(self.webhook_urls)}",
                    timestamp=datetime.now()
                )
            else:
                return NotificationResult(
                    channel=NotificationChannel.WEBHOOK,
                    success=False,
                    message=f"ÏõπÌõÖ Ï†ÑÏÜ° Ïã§Ìå®: {'; '.join(errors)}",
                    timestamp=datetime.now()
                )
            
        except Exception as e:
            return NotificationResult(
                channel=NotificationChannel.WEBHOOK,
                success=False,
                message=f"ÏõπÌõÖ Ï†ÑÏÜ° Ïò§Î•ò: {str(e)}",
                timestamp=datetime.now()
            )

# ============================================================================
# üèÜ ÌÜµÌï© ÏïåÎ¶º Í¥ÄÎ¶¨Ïûê
# ============================================================================

class QuintNotificationManager:
    """ÌÄ∏Ìä∏ÌîÑÎ°úÏ†ùÌä∏ ÌÜµÌï© ÏïåÎ¶º Í¥ÄÎ¶¨Ïûê"""
    
    def __init__(self, config_file: str = "notification_config.json"):
        self.config_manager = NotificationConfigManager(config_file)
        self.stats_manager = NotificationStatsManager()
        self.handlers = {}
        self._init_handlers()
        
        logger.info("üèÜ ÌÄ∏Ìä∏ÌîÑÎ°úÏ†ùÌä∏ ÌÜµÌï© ÏïåÎ¶º ÏãúÏä§ÌÖú Ï¥àÍ∏∞Ìôî ÏôÑÎ£å")
    
    def _init_handlers(self):
        """Ìï∏Îì§Îü¨ Ï¥àÍ∏∞Ìôî"""
        config = self.config_manager.config
        
        # ÌÖîÎ†àÍ∑∏Îû®
        if config.telegram_enabled and config.telegram_bot_token and config.telegram_chat_id:
            self.handlers[NotificationChannel.TELEGRAM] = TelegramHandler(
                config.telegram_bot_token, config.telegram_chat_id
            )
            logger.info("‚úÖ ÌÖîÎ†àÍ∑∏Îû® Ìï∏Îì§Îü¨ Ï¥àÍ∏∞Ìôî")
        
        # Ïù¥Î©îÏùº
        if config.email_enabled and config.email_username and config.email_password and config.email_to:
            self.handlers[NotificationChannel.EMAIL] = EmailHandler(
                config.email_smtp_server, config.email_smtp_port,
                config.email_username, config.email_password, config.email_to
            )
            logger.info(f"‚úÖ Ïù¥Î©îÏùº Ìï∏Îì§Îü¨ Ï¥àÍ∏∞Ìôî ({len(config.email_to)}Í∞ú Ï£ºÏÜå)")
        
        # Ïä¨Îûô
        if config.slack_enabled and config.slack_webhook_url:
            self.handlers[NotificationChannel.SLACK] = SlackHandler(
                config.slack_webhook_url, config.slack_channel
            )
            logger.info("‚úÖ Ïä¨Îûô Ìï∏Îì§Îü¨ Ï¥àÍ∏∞Ìôî")
        
        # ÎîîÏä§ÏΩîÎìú
        if config.discord_enabled and config.discord_webhook_url:
            self.handlers[NotificationChannel.DISCORD] = DiscordHandler(
                config.discord_webhook_url
            )
            logger.info("‚úÖ ÎîîÏä§ÏΩîÎìú Ìï∏Îì§Îü¨ Ï¥àÍ∏∞Ìôî")
        
        # SMS
        if config.sms_enabled and config.sms_account_sid and config.sms_auth_token:
            self.handlers[NotificationChannel.SMS] = SMSHandler(
                config.sms_account_sid, config.sms_auth_token,
                config.sms_from_number, config.sms_to_numbers
            )
            logger.info(f"‚úÖ SMS Ìï∏Îì§Îü¨ Ï¥àÍ∏∞Ìôî ({len(config.sms_to_numbers)}Í∞ú Î≤àÌò∏)")
        
        # ÏõπÌõÖ
        if config.webhook_enabled and config.webhook_urls:
            self.handlers[NotificationChannel.WEBHOOK] = WebhookHandler(
                config.webhook_urls
            )
            logger.info(f"‚úÖ ÏõπÌõÖ Ìï∏Îì§Îü¨ Ï¥àÍ∏∞Ìôî ({len(config.webhook_urls)}Í∞ú URL)")
        
        logger.info(f"üéØ ÌôúÏÑ±ÌôîÎêú Ï±ÑÎÑê: {list(self.handlers.keys())}")
    
    async def send_notification(self, title: str, message: str, 
                              level: NotificationLevel = NotificationLevel.INFO,
                              channels: Optional[List[NotificationChannel]] = None,
                              attachments: Optional[List[str]] = None,
                              metadata: Optional[Dict[str, Any]] = None) -> Dict[NotificationChannel, NotificationResult]:
        """ÌÜµÌï© ÏïåÎ¶º Ï†ÑÏÜ°"""
        
        # Î©îÏãúÏßÄ Í∞ùÏ≤¥ ÏÉùÏÑ±
        notification = NotificationMessage(
            title=title,
            message=message,
            level=level,
            channels=channels,
            attachments=attachments,
            metadata=metadata,
            message_id=self._generate_message_id(title, message, level)
        )
        
        # Ï§ëÎ≥µ Ï≤¥ÌÅ¨
        if self.config_manager.config.duplicate_prevention:
            if self.stats_manager.check_duplicate(notification, 
                                                 self.config_manager.config.duplicate_window_minutes):
                logger.info(f"‚ö†Ô∏è Ï§ëÎ≥µ ÏïåÎ¶º Í∞êÏßÄ, Ïä§ÌÇµ: {title}")
                return {}
        
        # Ï±ÑÎÑê Í≤∞Ï†ï
        target_channels = self._determine_channels(notification)
        
        # ÏïåÎ¶º Ï†ÑÏÜ°
        results = {}
        for channel in target_channels:
            if channel in self.handlers:
                result = await self._send_with_retry(notification, channel)
                results[channel] = result
                
                # ÌÜµÍ≥Ñ Í∏∞Î°ù
                response_time = int((result.timestamp - notification.timestamp).total_seconds() * 1000)
                self.stats_manager.log_notification(notification, result, response_time)
        
        # Í≤∞Í≥º Î°úÍπÖ
        success_count = sum(1 for r in results.values() if r.success)
        total_count = len(results)
        
        if success_count == total_count:
            logger.info(f"‚úÖ ÏïåÎ¶º Ï†ÑÏÜ° ÏôÑÎ£å: {title} ({success_count}/{total_count} ÏÑ±Í≥µ)")
        elif success_count > 0:
            logger.warning(f"‚ö†Ô∏è Î∂ÄÎ∂Ñ Ï†ÑÏÜ° ÏôÑÎ£å: {title} ({success_count}/{total_count} ÏÑ±Í≥µ)")
        else:
            logger.error(f"‚ùå ÏïåÎ¶º Ï†ÑÏÜ° Ïã§Ìå®: {title} (Î™®Îì† Ï±ÑÎÑê Ïã§Ìå®)")
        
        return results
    
    def _generate_message_id(self, title: str, message: str, level: NotificationLevel) -> str:
        """Î©îÏãúÏßÄ ID ÏÉùÏÑ±"""
        content = f"{title}:{message}:{level.value}:{datetime.now().isoformat()}"
        return hashlib.sha256(content.encode()).hexdigest()[:16]
    
    def _determine_channels(self, notification: NotificationMessage) -> List[NotificationChannel]:
        """ÎåÄÏÉÅ Ï±ÑÎÑê Í≤∞Ï†ï"""
        # Î™ÖÏãúÏ†Å Ï±ÑÎÑê ÏßÄÏ†ïÏù¥ ÏûàÏúºÎ©¥ ÏÇ¨Ïö©
        if notification.channels:
            return [ch for ch in notification.channels if ch in self.handlers]
        
        # Î†àÎ≤®Î≥Ñ Í∏∞Î≥∏ Ï±ÑÎÑê ÏÇ¨Ïö©
        level_channels = self.config_manager.config.level_channels.get(notification.level.value, [])
        channels = []
        
        for channel_name in level_channels:
            try:
                channel = NotificationChannel(channel_name)
                if channel in self.handlers:
                    channels.append(channel)
            except ValueError:
                continue
        
        return channels
    
    async def _send_with_retry(self, notification: NotificationMessage, 
                              channel: NotificationChannel) -> NotificationResult:
        """Ïû¨ÏãúÎèÑ Î°úÏßÅÏù¥ Ìè¨Ìï®Îêú Ï†ÑÏÜ°"""
        handler = self.handlers[channel]
        max_retries = self.config_manager.config.max_retries
        retry_delay = self.config_manager.config.retry_delay_seconds
        
        for attempt in range(max_retries + 1):
            try:
                result = await handler.send_message(notification)
                result.retry_count = attempt
                
                if result.success:
                    return result
                
                # Ïã§Ìå® Ïãú Ïû¨ÏãúÎèÑ (ÎßàÏßÄÎßâ ÏãúÎèÑÍ∞Ä ÏïÑÎãå Í≤ΩÏö∞)
                if attempt < max_retries:
                    logger.warning(f"üîÑ {channel.value} Ïû¨ÏãúÎèÑ {attempt + 1}/{max_retries}: {result.message}")
                    await asyncio.sleep(retry_delay)
                else:
                    logger.error(f"‚ùå {channel.value} ÏµúÏ¢Ö Ïã§Ìå®: {result.message}")
                    return result
                
            except Exception as e:
                if attempt < max_retries:
                    logger.warning(f"üîÑ {channel.value} ÏòàÏô∏ Ïû¨ÏãúÎèÑ {attempt + 1}/{max_retries}: {str(e)}")
                    await asyncio.sleep(retry_delay)
                else:
                    return NotificationResult(
                        channel=channel,
                        success=False,
                        message=f"ÏµúÏ¢Ö Ïã§Ìå®: {str(e)}",
                        timestamp=datetime.now(),
                        retry_count=attempt
                    )
        
        # Ïù¥Î°†Ï†ÅÏúºÎ°ú ÎèÑÎã¨ÌïòÏßÄ ÏïäÏùå
        return NotificationResult(
            channel=channel,
            success=False,
            message="Ïïå Ïàò ÏóÜÎäî Ïò§Î•ò",
            timestamp=datetime.now(),
            retry_count=max_retries
        )
    
    # ========================================================================
    # üéØ Ìé∏Ïùò Î©îÏÑúÎìúÎì§
    # ========================================================================
    
    async def send_info(self, title: str, message: str, **kwargs):
        """Ï†ïÎ≥¥ ÏïåÎ¶º Ï†ÑÏÜ°"""
        return await self.send_notification(title, message, NotificationLevel.INFO, **kwargs)
    
    async def send_warning(self, title: str, message: str, **kwargs):
        """Í≤ΩÍ≥† ÏïåÎ¶º Ï†ÑÏÜ°"""
        return await self.send_notification(title, message, NotificationLevel.WARNING, **kwargs)
    
    async def send_critical(self, title: str, message: str, **kwargs):
        """Ï§ëÏöî ÏïåÎ¶º Ï†ÑÏÜ°"""
        return await self.send_notification(title, message, NotificationLevel.CRITICAL, **kwargs)
    
    async def send_emergency(self, title: str, message: str, **kwargs):
        """Í∏¥Í∏â ÏïåÎ¶º Ï†ÑÏÜ°"""
        return await self.send_notification(title, message, NotificationLevel.EMERGENCY, **kwargs)
    
    async def send_trade_alert(self, symbol: str, action: str, price: float, quantity: float, 
                              strategy: str, profit_loss: Optional[float] = None):
        """Í±∞Îûò ÏïåÎ¶º Ï†ÑÏÜ°"""
        emoji = "üìà" if action.upper() == "BUY" else "üìâ"
        
        message = f"""
{emoji} Í±∞Îûò Ïã§Ìñâ

Ï¢ÖÎ™©: {symbol}
Ïï°ÏÖò: {action.upper()}
Í∞ÄÍ≤©: {price:,.2f}
ÏàòÎüâ: {quantity:,.2f}
Ï†ÑÎûµ: {strategy}
"""
        
        if profit_loss is not None:
            pnl_emoji = "üí∞" if profit_loss > 0 else "üí∏"
            message += f"{pnl_emoji} ÏÜêÏùµ: {profit_loss:+,.2f}\n"
        
        message += f"ÏãúÍ∞Ñ: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
        
        return await self.send_info(f"Í±∞Îûò Ïã§Ìñâ: {symbol}", message)
    
    async def send_portfolio_summary(self, total_value: float, total_pnl: float, 
                                   total_return_pct: float, positions_count: int):
        """Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ ÏöîÏïΩ ÏïåÎ¶º"""
        pnl_emoji = "üìà" if total_pnl >= 0 else "üìâ"
        
        message = f"""
üíº Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ ÌòÑÌô©

Ï¥ù Í∞ÄÏπò: ${total_value:,.2f}
{pnl_emoji} ÏÜêÏùµ: ${total_pnl:+,.2f} ({total_return_pct:+.2f}%)
Ìè¨ÏßÄÏÖò Ïàò: {positions_count}Í∞ú

ÏóÖÎç∞Ïù¥Ìä∏: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
"""
        
        level = NotificationLevel.INFO if total_pnl >= 0 else NotificationLevel.WARNING
        return await self.send_notification("Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ ÏöîÏïΩ", message, level)
    
    async def send_system_alert(self, system_name: str, status: str, details: str = ""):
        """ÏãúÏä§ÌÖú ÏÉÅÌÉú ÏïåÎ¶º"""
        if status.upper() == "UP":
            emoji = "‚úÖ"
            level = NotificationLevel.INFO
        elif status.upper() == "WARNING":
            emoji = "‚ö†Ô∏è"
            level = NotificationLevel.WARNING
        else:
            emoji = "üö®"
            level = NotificationLevel.CRITICAL
        
        message = f"""
{emoji} ÏãúÏä§ÌÖú ÏÉÅÌÉú Î≥ÄÍ≤Ω

ÏãúÏä§ÌÖú: {system_name}
ÏÉÅÌÉú: {status.upper()}
"""
        
        if details:
            message += f"ÏÉÅÏÑ∏: {details}\n"
        
        message += f"ÏãúÍ∞Ñ: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
        
        return await self.send_notification(f"ÏãúÏä§ÌÖú ÏïåÎ¶º: {system_name}", message, level)
    
    # ========================================================================
    # üìä Í¥ÄÎ¶¨ Î∞è Ïú†Ìã∏Î¶¨Ìã∞ Î©îÏÑúÎìú
    # ========================================================================
    
    def get_stats(self, days: int = 7) -> Dict[str, Any]:
        """ÏïåÎ¶º ÌÜµÍ≥Ñ Ï°∞Ìöå"""
        return self.stats_manager.get_stats(days)
    
    def get_config(self) -> NotificationConfig:
        """ÌòÑÏû¨ ÏÑ§Ï†ï Ï°∞Ìöå"""
        return self.config_manager.config
    
    def update_config(self, **kwargs):
        """ÏÑ§Ï†ï ÏóÖÎç∞Ïù¥Ìä∏"""
        self.config_manager.update_config(**kwargs)
        self._init_handlers()  # Ìï∏Îì§Îü¨ Ïû¨Ï¥àÍ∏∞Ìôî
        logger.info("‚öôÔ∏è ÏÑ§Ï†ï ÏóÖÎç∞Ïù¥Ìä∏ Î∞è Ìï∏Îì§Îü¨ Ïû¨Ï¥àÍ∏∞Ìôî ÏôÑÎ£å")
    
    def test_channels(self) -> Dict[NotificationChannel, bool]:
        """Ï±ÑÎÑê Ïó∞Í≤∞ ÌÖåÏä§Ìä∏"""
        async def _test_all():
            test_message = NotificationMessage(
                title="ÏïåÎ¶º ÏãúÏä§ÌÖú ÌÖåÏä§Ìä∏",
                message="Ïù¥Í≤ÉÏùÄ ÏïåÎ¶º ÏãúÏä§ÌÖú Ïó∞Í≤∞ ÌÖåÏä§Ìä∏ Î©îÏãúÏßÄÏûÖÎãàÎã§.",
                level=NotificationLevel.DEBUG
            )
            
            results = {}
            for channel, handler in self.handlers.items():
                try:
                    result = await handler.send_message(test_message)
                    results[channel] = result.success
                except Exception as e:
                    logger.error(f"Ï±ÑÎÑê ÌÖåÏä§Ìä∏ Ïã§Ìå® {channel}: {e}")
                    results[channel] = False
            
            return results
        
        return asyncio.run(_test_all())
    
    def get_active_channels(self) -> List[NotificationChannel]:
        """ÌôúÏÑ±ÌôîÎêú Ï±ÑÎÑê Î™©Î°ù"""
        return list(self.handlers.keys())
    
    def is_channel_active(self, channel: NotificationChannel) -> bool:
        """ÌäπÏ†ï Ï±ÑÎÑê ÌôúÏÑ±Ìôî Ïó¨Î∂Ä"""
        return channel in self.handlers

# ============================================================================
# üß™ ÌÖåÏä§Ìä∏ Î∞è ÏòàÏ†ú Ìï®ÏàòÎì§
# ============================================================================

async def test_notification_system():
    """ÏïåÎ¶º ÏãúÏä§ÌÖú ÌÖåÏä§Ìä∏"""
    print("üß™ ÌÄ∏Ìä∏ÌîÑÎ°úÏ†ùÌä∏ ÏïåÎ¶º ÏãúÏä§ÌÖú ÌÖåÏä§Ìä∏ ÏãúÏûë")
    
    # ÏïåÎ¶º Í¥ÄÎ¶¨Ïûê Ï¥àÍ∏∞Ìôî
    notifier = QuintNotificationManager()
    
    # Ï±ÑÎÑê ÌÖåÏä§Ìä∏
    print("\nüì° Ï±ÑÎÑê Ïó∞Í≤∞ ÌÖåÏä§Ìä∏")
    test_results = notifier.test_channels()
    for channel, success in test_results.items():
        status = "‚úÖ ÏÑ±Í≥µ" if success else "‚ùå Ïã§Ìå®"
        print(f"  {channel.value}: {status}")
    
    # Îã§ÏñëÌïú Î†àÎ≤® ÌÖåÏä§Ìä∏
    print("\nüì¢ ÏïåÎ¶º Î†àÎ≤® ÌÖåÏä§Ìä∏")
    
    await notifier.send_info("Ï†ïÎ≥¥ ÏïåÎ¶º ÌÖåÏä§Ìä∏", "Ïù¥Í≤ÉÏùÄ ÏùºÎ∞ò Ï†ïÎ≥¥ ÏïåÎ¶ºÏûÖÎãàÎã§.")
    await asyncio.sleep(1)
    
    await notifier.send_warning("Í≤ΩÍ≥† ÏïåÎ¶º ÌÖåÏä§Ìä∏", "Ï£ºÏùòÍ∞Ä ÌïÑÏöîÌïú ÏÉÅÌô©ÏûÖÎãàÎã§.")
    await asyncio.sleep(1)
    
    await notifier.send_critical("Ï§ëÏöî ÏïåÎ¶º ÌÖåÏä§Ìä∏", "Ï¶âÏãú ÌôïÏù∏Ïù¥ ÌïÑÏöîÌïú ÏÉÅÌô©ÏûÖÎãàÎã§.")
    await asyncio.sleep(1)
    
    # Í±∞Îûò ÏïåÎ¶º ÌÖåÏä§Ìä∏
    print("\nüí∞ Í±∞Îûò ÏïåÎ¶º ÌÖåÏä§Ìä∏")
    await notifier.send_trade_alert("AAPL", "BUY", 150.25, 100, "ÎØ∏Íµ≠Ï†ÑÎûµ", 1250.50)
    await asyncio.sleep(1)
    
    # Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ ÏöîÏïΩ ÌÖåÏä§Ìä∏
    print("\nüìä Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ ÏöîÏïΩ ÌÖåÏä§Ìä∏")
    await notifier.send_portfolio_summary(100000, 5000, 5.0, 15)
    await asyncio.sleep(1)
    
    # ÏãúÏä§ÌÖú ÏïåÎ¶º ÌÖåÏä§Ìä∏
    print("\nüñ•Ô∏è ÏãúÏä§ÌÖú ÏïåÎ¶º ÌÖåÏä§Ìä∏")
    await notifier.send_system_alert("Í±∞ÎûòÏãúÏä§ÌÖú", "UP", "Î™®Îì† ÏãúÏä§ÌÖúÏù¥ Ï†ïÏÉÅ ÏûëÎèô Ï§ëÏûÖÎãàÎã§.")
    
    # ÌÜµÍ≥Ñ Ï∂úÎ†•
    print("\nüìà ÏïåÎ¶º ÌÜµÍ≥Ñ")
    stats = notifier.get_stats(1)  # ÏµúÍ∑º 1Ïùº
    print(f"Ï¥ù ÏïåÎ¶º Ïàò: {stats.get('total_notifications', 0)}")
    
    for channel, data in stats.get('channel_stats', {}).items():
        print(f"  {channel}: {data['successful_sent']}/{data['total_sent']} ÏÑ±Í≥µ ({data['success_rate']:.1f}%)")
    
    print("\n‚úÖ ÏïåÎ¶º ÏãúÏä§ÌÖú ÌÖåÏä§Ìä∏ ÏôÑÎ£å")

async def example_usage():
    """ÏÇ¨Ïö© ÏòàÏ†ú"""
    print("üìö ÌÄ∏Ìä∏ÌîÑÎ°úÏ†ùÌä∏ ÏïåÎ¶º ÏãúÏä§ÌÖú ÏÇ¨Ïö© ÏòàÏ†ú")
    
    # 1. Í∏∞Î≥∏ Ï¥àÍ∏∞Ìôî
    notifier = QuintNotificationManager()
    
    # 2. Í∞ÑÎã®Ìïú Ï†ïÎ≥¥ ÏïåÎ¶º
    await notifier.send_info("ÏãúÏä§ÌÖú ÏãúÏûë", "ÌÄ∏Ìä∏ÌîÑÎ°úÏ†ùÌä∏Í∞Ä ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏãúÏûëÎêòÏóàÏäµÎãàÎã§.")
    
    # 3. ÌäπÏ†ï Ï±ÑÎÑêÎßå ÏÇ¨Ïö©
    await notifier.send_warning(
        "ÎÑ§Ìä∏ÏõåÌÅ¨ ÏßÄÏó∞", 
        "ÎÑ§Ìä∏ÏõåÌÅ¨ ÏùëÎãµÏù¥ ÎäêÎ†§ÏßÄÍ≥† ÏûàÏäµÎãàÎã§.",
        channels=[NotificationChannel.TELEGRAM, NotificationChannel.SLACK]
    )
    
    # 4. Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ÏôÄ Ìï®Íªò
    await notifier.send_critical(
        "Ìè¨ÏßÄÏÖò ÏúÑÌóò",
        "ÏùºÎ∂Ä Ìè¨ÏßÄÏÖòÏóêÏÑú ÌÅ∞ ÏÜêÏã§Ïù¥ Î∞úÏÉùÌñàÏäµÎãàÎã§.",
        metadata={
            "strategy": "ÎØ∏Íµ≠Ï†ÑÎûµ",
            "symbol": "TSLA",
            "loss_amount": -5000
        }
    )
    
    # 5. Í±∞Îûò Í¥ÄÎ†® Ìé∏Ïùò Î©îÏÑúÎìú
    await notifier.send_trade_alert("BTC", "SELL", 45000, 0.1, "ÏïîÌò∏ÌôîÌèêÏ†ÑÎûµ", 500)
    
    # 6. ÏÑ§Ï†ï ÎèôÏ†Å Î≥ÄÍ≤Ω
    notifier.update_config(
        telegram_enabled=True,
        telegram_bot_token="ÏÉàÌÜ†ÌÅ∞",
        duplicate_window_minutes=10
    )
    
    print("‚úÖ ÏÇ¨Ïö© ÏòàÏ†ú ÏôÑÎ£å")

def create_default_config():
    """Í∏∞Î≥∏ ÏÑ§Ï†ï ÌååÏùº ÏÉùÏÑ±"""
    config = {
        "telegram_enabled": False,
        "telegram_bot_token": "",
        "telegram_chat_id": "",
        "email_enabled": False,
        "email_smtp_server": "smtp.gmail.com",
        "email_smtp_port": 587,
        "email_username": "",
        "email_password": "",
        "email_to": [],
        "slack_enabled": False,
        "slack_webhook_url": "",
        "slack_channel": "#general",
        "discord_enabled": False,
        "discord_webhook_url": "",
        "sms_enabled": False,
        "sms_account_sid": "",
        "sms_auth_token": "",
        "sms_from_number": "",
        "sms_to_numbers": [],
        "webhook_enabled": False,
        "webhook_urls": [],
        "level_channels": {
            "debug": ["telegram"],
            "info": ["telegram", "slack"],
            "warning": ["telegram", "email", "slack"],
            "critical": ["telegram", "email", "slack", "discord"],
            "emergency": ["telegram", "email", "slack", "discord", "sms"]
        },
        "duplicate_prevention": True,
        "duplicate_window_minutes": 5,
        "max_retries": 3,
        "retry_delay_seconds": 5
    }
    
    with open("notification_config.json", "w", encoding="utf-8") as f:
        json.dump(config, f, indent=2, ensure_ascii=False)
    
    print("‚úÖ Í∏∞Î≥∏ ÏÑ§Ï†ï ÌååÏùº ÏÉùÏÑ±: notification_config.json")
    print("üìù ÏÑ§Ï†ïÏùÑ ÏàòÏ†ïÌïú ÌõÑ ÏïåÎ¶º ÏãúÏä§ÌÖúÏùÑ ÏÇ¨Ïö©ÌïòÏÑ∏Ïöî.")

# ============================================================================
# üéÆ CLI Ïù∏ÌÑ∞ÌéòÏù¥Ïä§
# ============================================================================

async def main():
    """Î©îÏù∏ Ìï®Ïàò"""
    import sys
    
    if len(sys.argv) > 1:
        command = sys.argv[1].lower()
        
        if command == "test":
            await test_notification_system()
        elif command == "example":
            await example_usage()
        elif command == "config":
            create_default_config()
        elif command == "stats":
            notifier = QuintNotificationManager()
            stats = notifier.get_stats(7)
            print(json.dumps(stats, indent=2, ensure_ascii=False, default=str))
        else:
            print(f"‚ùå Ïïå Ïàò ÏóÜÎäî Î™ÖÎ†πÏñ¥: {command}")
    else:
        print("""
üèÜ ÌÄ∏Ìä∏ÌîÑÎ°úÏ†ùÌä∏ ÌÜµÌï© ÏïåÎ¶º ÏãúÏä§ÌÖú

ÏÇ¨Ïö©Î≤ï:
  python notifier.py test      # ÏïåÎ¶º ÏãúÏä§ÌÖú ÌÖåÏä§Ìä∏
  python notifier.py example   # ÏÇ¨Ïö© ÏòàÏ†ú Ïã§Ìñâ
  python notifier.py config    # Í∏∞Î≥∏ ÏÑ§Ï†ï ÌååÏùº ÏÉùÏÑ±
  python notifier.py stats     # ÏïåÎ¶º ÌÜµÍ≥Ñ Ï°∞Ìöå

ÎùºÏù¥Î∏åÎü¨Î¶¨Î°ú ÏÇ¨Ïö©:
  from notifier import QuintNotificationManager
  notifier = QuintNotificationManager()
  await notifier.send_info("Ï†úÎ™©", "Î©îÏãúÏßÄ")
""")

if __name__ == "__main__":
    asyncio.run(main())
